jpeg(file=paste(workdir,template,"_distance-Pr(MID).jpg",sep = ""))
plot(xlab = "x = |M* - M| = distance from the main mode",ylim = y.post.lim, ylab="Pr(MID)",y=c(statistics1[moddee,4],statistics1[-moddee,4])/norm1,x=dists,pch=19, col = 7,cex= 3*((statistics1[,9]+statistics1[,5]+statistics1[,6]+statistics1[,7]+statistics1[,8])>0))
points(y=c(statistics1[moddee,4],statistics1[-moddee,4])/norm1,x=dists,pch=8,  col = ifelse(c(statistics1[moddee,4],statistics1[-moddee,4])>0,5,0),cex= ifelse(c(statistics1[moddee,4],statistics1[-moddee,4])>0,c(statistics1[moddee,4],statistics1[-moddee,4])/norm+1,0))
points(y=c(statistics1[moddee,4],statistics1[-moddee,4])/norm1,x=dists,pch=2,  col = ifelse(c(statistics1[moddee,10],statistics1[-moddee,10])>0,2,0),cex= ifelse(c(statistics1[moddee,10],statistics1[-moddee,10])>0,c(statistics1[moddee,10],statistics1[-moddee,10])/norm+1,0))
points(y=c(statistics1[moddee,4],statistics1[-moddee,4])/norm1,x=dists,pch=3,  col = ifelse(c(statistics1[moddee,11],statistics1[-moddee,11])>0,3,0),cex= ifelse(c(statistics1[moddee,11],statistics1[-moddee,11])>0,c(statistics1[moddee,11],statistics1[-moddee,11])/norm+1,0))
points(y=c(statistics1[moddee,4],statistics1[-moddee,4])/norm1,x=dists,pch=4,  col = ifelse(c(statistics1[moddee,12],statistics1[-moddee,12])>0,4,0),cex= ifelse(c(statistics1[moddee,12],statistics1[-moddee,12])>0,c(statistics1[moddee,12],statistics1[-moddee,12])/norm+1,0))
points(y=c(statistics1[moddee,4],statistics1[-moddee,4])/norm1,x=dists,pch=6,  col = ifelse(c(statistics1[moddee,13],statistics1[-moddee,13])>0,6,0),cex= ifelse(c(statistics1[moddee,13],statistics1[-moddee,13])>0,c(statistics1[moddee,13],statistics1[-moddee,13])/norm+1,0))
points(y=c(statistics1[moddee,4],statistics1[-moddee,4])/norm1,x=dists,pch=1,  col = ifelse(c(statistics1[moddee,14],statistics1[-moddee,14])>0,1,0),cex= ifelse(c(statistics1[moddee,14],statistics1[-moddee,14])>0,c(statistics1[moddee,14],statistics1[-moddee,14])/norm+1,0))
points(y= c(zyx[moddee],zyx[-moddee]),x=dists,pch=20,  col = 2,cex= 2)
dev.off()
})), abort = function(){onerr<-TRUE})})
}
if(crit$mlik)
{
if(printable.opt)print(paste("drawing ",workdir,template,"_mds-Pr(MID).jpg",sep = ""))
if(printable.opt)print("Calculating distance matrix, may take a significant amount of time, may also produce errors if your machine does not have enough memory")
capture.output({withRestarts(tryCatch(capture.output({
# further address subset of the set of the best solution of cardinality 1024
if(lldd>mds_size)
{
lldd<-mds_size
quant<-(sort(statistics1[,1],decreasing = TRUE)[lldd+1])
indmds<-which(statistics1[,1]>quant)
length(indmds)
}else{
quant<- -Inf
indmds<-1:(lldd)
}
vec<-dectobit.alt(moddee-1)
varcur<-c(array(0,dim = (Nvars -length(vec))),vec)
df = data.frame(varcur)
for(i in 1:(lldd-1))
{
if(i==moddee)
{
next
}else
{
vec<-dectobit.alt(indmds[i]-1)
varcur<-c(array(0,dim = (Nvars -length(vec))),vec)
df<-cbind(df,varcur)
#colnames(x = df)[i] <- paste("solution ",i)
}
}
df<-t(df)
x<-dist(x = df,method = "binary")
dists<-c(0,x[1:lldd-1])
fit.mds <- cmdscale(d = x,eig=FALSE, k=2) # k is the number of dim
#fit.mds # view results
x.mds <- fit.mds[,1]
y.mds <- fit.mds[,2]
jpeg(file=paste(workdir,template,"_mds_map_posteriors.jpg",sep = ""))
plot(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=5,pch = 8,cex= ifelse(c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])>0,c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])/norm1*50,0))
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=2,pch = 10,cex= c(zyx[moddee],zyx[setdiff(indmds, moddee)])*50,0)
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=2,pch = 10,cex= c(zyx[moddee],zyx[setdiff(indmds, moddee)])*50,0)
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=5,pch = 8,cex= ifelse(c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])>0,c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])/norm1*50,0))
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=5,pch = 8,cex= ifelse(c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])>0,c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])/norm1*50,0))
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=5,pch = 8,cex= ifelse(c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])>0,c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])/norm1*50,0))
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=5,pch = 8,cex= ifelse(c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])>0,c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])/norm1*50,0))
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=5,pch = 8,cex= ifelse(c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])>0,c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])/norm1*50,0))
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=5,pch = 8,cex= ifelse(c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])>0,c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])/norm1*50,0))
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=5,pch = 8,cex= ifelse(c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])>0,c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])/norm1*50,0))
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=5,pch = 8,cex= ifelse(c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])>0,c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])/norm1*50,0))
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=5,pch = 8,cex= ifelse(c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])>0,c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])/norm1*50,0))
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=5,pch = 8,cex= ifelse(c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])>0,c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])/norm1*50,0))
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=5,pch = 8,cex= ifelse(c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])>0,c(statistics1[moddee,4],statistics1[setdiff(indmds, moddee),4])/norm1*50,0))
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=7,pch = 19,cex= 0.4)
points(x.mds[], y.mds[], xlab="Coordinate 1", ylab="Coordinate 2", main="Metric MDS", type="p",col=1,pch = 19,cex= 0.01)
dev.off()
})), abort = function(){onerr<-TRUE})})
}
}
},
#calculates posterior probabilities based on a current search
post_proceed_results = function(statistics1)
{
xyz<-which(!is.na(statistics1[,1]))
g.results[4,2] <- length(xyz)
xyz<-intersect(xyz,which(statistics1[,1]!=-10000))
moddee<-which(statistics1[,1]==max(statistics1[,1],na.rm = TRUE))[1]
zyx<-array(data = NA,dim = length(statistics1[,1]))
nconsum<-sum(exp(-statistics1[moddee,1]+statistics1[xyz,1]),na.rm = TRUE)
if( nconsum > 0)
{
zyx[xyz]<-exp(statistics1[xyz,1]-statistics1[moddee,1])/nconsum
}else{
nnnorm<-sum(statistics1[xyz,4],na.rm = T)
if(nnnorm==0)
nnnorm <- 1
zyx[xyz]<-statistics1[xyz,4]/nnnorm
}
statistics1[,15]<-zyx
lldd<-2^(Nvars)+1
p.post<-array(data = 0,dim = Nvars)
for(i in xyz)
{
vec<-dectobit(i-1)
varcur<-c(array(0,dim = (Nvars -length(vec))),vec)
p.post <- (p.post + varcur*statistics1[i,15])
}
if(!exists("p.post")||is.null(p.post)||sum(p.post,na.rm = T)==0 || sum(p.post,na.rm = T)>Nvars)
{
p.post <- array(data = 0.5,dim = Nvars)
}
return(list(p.post = p.post, m.post = zyx, s.mass = sum(exp(statistics1[xyz,1]),na.rm = TRUE)))
},
post_proceed_results_hash = function(hashStat)
{
if(save.beta)
{
if(allow_offsprings==0||Nvars>Nvars.max)
{
if(fparam[1]=="Const")
{
linx<-Nvars + 3
}else
{
linx<-Nvars + 1 + 3
}
}else
{
if(fparam[1]=="Const")
{
linx<-Nvars.max + 3
}else
{
linx<-Nvars.max + 1 + 3
}
}
}else
{
linx <- 3
}
lHash<-length(hashStat)
mliks <- values(hashStat)[which((1:(lHash * linx)) %% linx == 1)]
xyz<-which(mliks!=-10000)
g.results[4,2] <- lHash
moddee<-which( mliks ==max( mliks ,na.rm = TRUE))[1]
zyx<-array(data = NA,dim = lHash)
nconsum<-sum(exp(- mliks[moddee]+ mliks[xyz]),na.rm = TRUE)
if( nconsum > 0)
{
zyx[xyz]<-exp(mliks[xyz]- mliks[moddee])/nconsum
}else{
diff<-0-mliks[moddee]
mliks<-mliks+diff
nconsum<-sum(exp(- mliks[moddee]+ mliks[xyz]),na.rm = TRUE)
zyx[xyz]<-exp(mliks[xyz]- mliks[moddee])/nconsum
}
keysarr <- as.array(keys(hashStat))
p.post<-array(data = 0,dim = Nvars)
for(i in 1:lHash)
{
if(is.na(zyx[i]))
{
del(x = keysarr[i],hash = hashStat)
next
}
#vec<-dectobit(strtoi(keysarr[i], base = 0L)-1) # we will have to write some function that would handle laaaaargeee integers!
varcur<- as.integer(strsplit(keysarr[i],split = "")[[1]])
if(length(which(is.na(varcur)))>0)
{
del(x = keysarr[i],hash = hashStat)
next
}
if(length(varcur)>Nvars)
varcur<-varcur[1:Nvars]
p.post <- (p.post + varcur*zyx[i])
}
if(!exists("p.post") || is.null(p.post) || sum(p.post,na.rm = T)==0 || sum(p.post,na.rm = T)>Nvars)
{
p.post <- array(data = 0.5,dim = Nvars)
}
#values(hashStat)[which((1:(lHash * linx)) %%linx == 4)]<-zyx
return(list(p.post = p.post, m.post = zyx, s.mass = sum(exp(mliks),na.rm = TRUE)))
},
calculate_quality_measures = function(vect,n,truth)
{
rmse.pi <- array(data = 0,Nvars)
bias.pi <- array(data = 0,Nvars)
for(i in 1:n)
{
bias.pi <- (bias.pi + (vect[,i]-truth))
rmse.pi <- (rmse.pi + (vect[,i]^2+truth^2 - 2*vect[,i]*truth))
}
bias.pi <- bias.pi/n
rmse.pi <- rmse.pi/n
return(list(bias.pi = bias.pi, rmse.pi = rmse.pi))
},
forecast=function(covariates,nvars,link.g)
{
ids<-which(!is.na(statistics1[,15]))
res<-0
for(i in ids)
{
res<-res + statistics1[i,15]*link.g(sum(statistics1[i,16:nvars]*covariates,na.rm = T))
}
return(list(forecast=res))
},
forecast.matrix=function(covariates,link.g)
{
res<-NULL
ncases <- dim(covariates)[1]
formula.cur<-as.formula(paste(fparam[1],"/2 ~",paste0(fparam,collapse = "+")))
nvars <- Nvars
if(save.beta)
{
if(exists("statistics1"))
{
ids<-which(!is.na(statistics1[,15]))
lids<-length(ids)
statistics1[ids,(17:(nvars+16))][which(is.na(statistics1[ids,(17:(nvars+16))]))]<-0
res<-t(statistics1[ids,15])%*%g(statistics1[ids,(16:(nvars+16))]%*%t(model.matrix(object = formula.cur,data = covariates)))
}else if(exists("hashStat"))
{
if(allow_offsprings==0)
{
if(fparam[1]=="Const")
{
linx<-Nvars + 3
}else
{
linx<-Nvars + 1 + 3
}
}else
{
if(fparam[1]=="Const")
{
linx<-Nvars.max + 3
}else
{
linx<-Nvars.max + 1 + 3
}
}
lHash<-length(hashStat)
mliks <- values(hashStat)[which((1:(lHash * linx)) %% linx == 1)]
betas <- values(hashStat)[which((1:(lHash * linx)) %% linx == 4)]
for(i in 1:(Nvars-1))
{
betas<-cbind(betas,values(hashStat)[which((1:(lHash * linx)) %% linx == (4+i))])
}
betas<-cbind(betas,values(hashStat)[which((1:(lHash * linx)) %% linx == (0))])
betas[which(is.na(betas))]<-0
xyz<-which(mliks!=-10000)
g.results[4,2] <- lHash
moddee<-which( mliks ==max( mliks ,na.rm = TRUE))[1]
zyx<-array(data = NA,dim = lHash)
nconsum<-sum(exp(- mliks[moddee]+ mliks[xyz]),na.rm = TRUE)
if( nconsum > 0)
{
zyx[xyz]<-exp(mliks[xyz]- mliks[moddee])/nconsum
}else{
diff<-0-mliks[moddee]
mliks<-mliks+diff
nconsum<-sum(exp(- mliks[moddee]+ mliks[xyz]),na.rm = TRUE)
zyx[xyz]<-exp(mliks[xyz]- mliks[moddee])/nconsum
}
res<-t(zyx)%*%g(betas%*%t(model.matrix(object = formula.cur,data = covariates)))
}
}else
{
warning("No betas were saved. Prediction is impossible. Please change the search parameters and run the search again.")
}
return(list(forecast=res))
},
forecast.matrix.na=function(covariates,link.g,betas,mliks.in)
{
formula2<-as.formula(paste(fparam[1],"/2 ~ -1+",paste0(fparam,collapse = "+")))
current.na.action <- options('na.action')
options(na.action='na.pass')
covariates<- as.data.frame(model.matrix(object = formula2,data = covariates,na.action=na.include))
options('na.action'=  current.na.action$na.action)
names(covariates)<-stri_replace_all(str = names(covariates),fixed = "I",replacement = "Z")
names(covariates)<-stri_replace_all(str = names(covariates),fixed = "(",replacement = "o")
names(covariates)<-stri_replace_all(str = names(covariates),fixed = ")",replacement = "c")
names(covariates)<-stri_replace_all(str = names(covariates),fixed = "+",replacement = "p")
names(covariates)<-stri_replace_all(str = names(covariates),fixed = "-",replacement = "m")
names(covariates)<-stri_replace_all(str = names(covariates),fixed = "*",replacement = "M")
names(covariates)<-stri_replace_all(str = names(covariates),fixed = "|",replacement = "a")
names(covariates)<-stri_replace_all(str = names(covariates),fixed = "&",replacement = "A")
names(covariates)<-stri_replace_all(str = names(covariates),fixed = ",",replacement = "k")
names(covariates)<-stri_replace_all(str = names(covariates),fixed = " ",replacement = "")
names(covariates)<-stri_replace_all(str = names(covariates),fixed = "\n",replacement = "")
names(covariates)<-stri_replace_all(str = names(covariates),fixed = "cFALSE",replacement = "c")
names(covariates)<-stri_replace_all(str = names(covariates),fixed = "cTRUE",replacement = "c")
fparam.tmp<-stri_replace_all(str = fparam,fixed = "I",replacement = "Z")
fparam.tmp<-stri_replace_all(str = fparam.tmp,fixed = "(",replacement = "o")
fparam.tmp<-stri_replace_all(str = fparam.tmp,fixed = ")",replacement = "c")
fparam.tmp<-stri_replace_all(str = fparam.tmp,fixed = "+",replacement = "p")
fparam.tmp<-stri_replace_all(str = fparam.tmp,fixed = "-",replacement = "m")
fparam.tmp<-stri_replace_all(str = fparam.tmp,fixed = ",",replacement = "k")
fparam.tmp<-stri_replace_all(str = fparam.tmp,fixed = "*",replacement = "M")
fparam.tmp<-stri_replace_all(str = fparam.tmp,fixed = "|",replacement = "a")
fparam.tmp<-stri_replace_all(str = fparam.tmp,fixed = "&",replacement = "A")
fparam.tmp<-stri_replace_all(str = fparam.tmp,fixed = " ",replacement = "")
fparam.tmp<-stri_replace_all(str = fparam.tmp,fixed = "\n",replacement = "")
formula.cur<-as.formula(paste(fparam.tmp[1],"/2 ~",paste0(fparam.tmp,collapse = "+")))
na.ids<-matrix(data = 0,nrow = dim(covariates)[1],ncol = dim(covariates)[2])
na.ids[which(is.na(covariates))]<-1
na.bc<-colSums(na.ids)
ids.betas<-NULL
res.na<-array(NA, dim(covariates)[1])
for(i in which(na.bc>0))
{
if(((names(covariates)[i] %in% fparam.tmp)||(paste0("Zo",names(covariates)[i],"c",collapse = "")%in%fparam.tmp)))
{
ids.betas<-c(ids.betas,which(fparam.tmp==names(covariates)[i] | fparam.tmp == paste0("Zo",names(covariates)[i],"c",collapse = "")))
next
}
else
{
na.ids[which(is.na(covariates[,i])),i]<-0
na.bc[i]<-0
}
}
na.br<-rowSums(na.ids)
lv.br<-sort(unique(na.br))
if(lv.br[1]==0)
{
ids<-which(na.br==0)
mliks<-mliks.in
xyz<-which(mliks!=-10000)
moddee<-which( mliks ==max( mliks ,na.rm = TRUE))[1]
zyx<-array(data = NA,dim = length(mliks))
nconsum<-sum(exp(- mliks[moddee]+ mliks[xyz]),na.rm = TRUE)
betas1<-betas
betas1[which(is.na(betas1))]<-0
if( nconsum > 0)
{
zyx[xyz]<-exp(mliks[xyz]- mliks[moddee])/nconsum
}else{
diff<-0-mliks[moddee]
mliks<-mliks+diff
nconsum<-sum(exp(- mliks[moddee]+ mliks[xyz]),na.rm = TRUE)
zyx[xyz]<-exp(mliks[xyz]- mliks[moddee])/nconsum
}
covariates1<- covariates[ids,]
res<-t(zyx)%*%g(betas1%*%t(model.matrix(object = as.formula(formula.cur),data = covariates1)))
res.na[ids]<-res
rm(mliks)
rm(res)
rm(zyx)
rm(xyz)
rm(covariates1)
rm(betas1)
}
k.b<-0
for(i in which(na.bc>0))
{
k.b<-k.b+1
w.ids<-which(!is.na(betas[,(ids.betas[k.b]+1)]))
for(j in lv.br)
{
if(j==0)
next
ids<-((which(na.ids[,i]==1 & na.br==j & is.na(res.na))))
if(length(ids)==0)
next
var.del <- NULL
for(iii in which(na.bc>0))
{
if(iii==i)
next
if(sum(na.ids[ids,iii])>0)
{
var.del<-(which(fparam.tmp==names(covariates)[iii] | fparam.tmp == paste0("I(",names(covariates)[iii],")",collapse = "")))
if(length(var.del>0))
{
w.ids<-union(w.ids,which(!is.na(betas[,(var.del+1)])))
}
}
}
mliks<-mliks.in[-w.ids]
if(length(mliks)==0)
{
warning("not enough models for bagging in prediction. please train the model longer!")
return(-1)
}
xyz<-which(mliks!=-10000)
moddee<-which( mliks ==max( mliks ,na.rm = TRUE))[1]
zyx<-array(data = NA,dim = length(mliks))
nconsum<-sum(exp(- mliks[moddee]+ mliks[xyz]),na.rm = TRUE)
betas1<-betas[-w.ids,]
betas1[which(is.na(betas1))]<-0
if( nconsum > 0)
{
zyx[xyz]<-exp(mliks[xyz]- mliks[moddee])/nconsum
}else{
diff<-0-mliks[moddee]
mliks<-mliks+diff
nconsum<-sum(exp(- mliks[moddee]+ mliks[xyz]),na.rm = TRUE)
zyx[xyz]<-exp(mliks[xyz]- mliks[moddee])/nconsum
}
covariates1<- as.matrix(covariates[ids,])
covariates1[which(is.na(covariates1))]<-0
covariates1<-as.data.frame(covariates1)
res<-t(zyx)%*%g(betas1%*%t(model.matrix(object = formula.cur,data = covariates1)))
res.na[ids]<-res
rm(mliks)
rm(zyx)
rm(xyz)
rm(res)
rm(covariates1)
}
}
return(list(forecast = res.na))
},
forecast.matrix.na.fast=function(covariates,link.g,betas,mliks.in)
{
formula.cur<-as.formula(paste(fparam[1],"/2 ~",paste0(fparam,collapse = "+")))
na.ids<-matrix(data = 0,nrow = dim(covariates)[1],ncol = dim(covariates)[2])
na.ids[which(is.na(covariates))]<-1
na.bc<-colSums(na.ids)
ids.betas<-NULL
res.na<-array(NA, dim(covariates)[1])
for(i in which(na.bc>0))
{
if(((names(covariates)[i] %in% fparam)||(paste0("I(",names(covariates)[i],")",collapse = "")%in%fparam)))
{
ids.betas<-c(ids.betas,which(fparam==names(covariates)[i] | fparam == paste0("I(",names(covariates)[i],")",collapse = "")))
next
}
else
{
na.ids[which(is.na(covariates[,i])),i]<-0
na.bc[i]<-0
}
}
na.br<-rowSums(na.ids)
lv.br<-sort(unique(na.br))
if(lv.br[1]==0)
{
ids<-which(na.br==0)
mliks<-mliks.in
xyz<-which(mliks!=-10000)
moddee<-which( mliks ==max( mliks ,na.rm = TRUE))[1]
zyx<-array(data = NA,dim = lHash)
nconsum<-sum(exp(- mliks[moddee]+ mliks[xyz]),na.rm = TRUE)
betas1<-betas
betas1[which(is.na(betas1))]<-0
if( nconsum > 0)
{
zyx[xyz]<-exp(mliks[xyz]- mliks[moddee])/nconsum
}else{
diff<-0-mliks[moddee]
mliks<-mliks+diff
nconsum<-sum(exp(- mliks[moddee]+ mliks[xyz]),na.rm = TRUE)
zyx[xyz]<-exp(mliks[xyz]- mliks[moddee])/nconsum
}
covariates1<- covariates[ids,]
res<-t(zyx)%*%g(betas1%*%t(model.matrix(object = formula.cur,data = covariates1)))
res.na[ids]<-res
rm(mliks)
rm(res)
rm(zyx)
rm(xyz)
rm(covariates1)
rm(betas1)
}
ids<-(which(is.na(res.na)))
for(iii in which(na.bc>0))
{
if(sum(na.ids[ids,iii])>0)
{
var.del<-(which(fparam==names(covariates)[iii] | fparam == paste0("I(",names(covariates)[iii],")",collapse = "")))
if(length(var.del>0))
{
w.ids<-union(w.ids,which(!is.na(betas[,(var.del+1)])))
}
}
}
mliks<-mliks.in[-w.ids]
if(length(mliks)==0)
{
warning("not enough models for bagging in prediction. please train the model longer!")
return(-1)
}
xyz<-which(mliks!=-10000)
moddee<-which( mliks ==max( mliks ,na.rm = TRUE))[1]
zyx<-array(data = NA,dim = length(mliks))
nconsum<-sum(exp(- mliks[moddee]+ mliks[xyz]),na.rm = TRUE)
betas1<-betas[-w.ids,]
betas1[which(is.na(betas1))]<-0
if( nconsum > 0)
{
zyx[xyz]<-exp(mliks[xyz]- mliks[moddee])/nconsum
}else{
diff<-0-mliks[moddee]
mliks<-mliks+diff
nconsum<-sum(exp(- mliks[moddee]+ mliks[xyz]),na.rm = TRUE)
zyx[xyz]<-exp(mliks[xyz]- mliks[moddee])/nconsum
}
covariates1<- as.matrix(covariates[ids,])
covariates1[which(is.na(covariates1))]<-0
covariates1<-as.data.frame(covariates1)
res<-t(zyx)%*%g(betas1%*%t(model.matrix(object = formula.cur,data = covariates1)))
res.na[ids]<-res
rm(mliks)
rm(zyx)
rm(xyz)
rm(res)
rm(covariates1)
return(list(forecast = res.na))
}
)
)
options(bigmemory.typecast.warning=FALSE)
library(EMJMCMC)
install.packages("https://github.com/aliaksah/EMJMCMC2016/blob/master/EMJMCMC_1.4.2_R_x86_64-pc-linux-gnu.tar.gz?raw=true", repos = NULL, type="source")
library(EMJMCMC)
??LogicRegr
??LogicRegr
